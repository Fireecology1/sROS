#Fixed form modelling
#Use to force a coefficient

#E.g., use for 25% surface ROS model
# ROS = 0.25 * ws
# sample data (actual sROS data) included in folder

#Manual code for model evaluation functions
rmse.manual <- function(actual, pred) {
  sqrt(mean(actual-pred)^2)
}

mae.manual <- function(actual, pred) {
  mean(abs(actual-pred))
}

mape.manual <- function(actual, pred) {
  mean(abs((actual-pred)/actual))
}

ef.r.squared <- function(actual, pred) {
  1- sum((actual - pred)^2) / sum((actual - mean(actual))^2)
}

aic.manual <- function(model) {
  n=length(model$residuals)
  rss=sum(model$residuals^2)
  k=length(coef(model)) + 1
  n* log(rss/n) + 2 * k
}

#save(rmse.manual, file='C:/Dan/_Fire_tools/r_scripts_functions/rmse.rda')
#save(mae.manual, file='C:/Dan/_Fire_tools/r_scripts_functions/mae.rda')
#save(mape.manual, file='C:/Dan/_Fire_tools/r_scripts_functions/mape.rda')
#save(rmse.manual, file='C:/Dan/_Fire_tools/r_scripts_functions/rmse.rda')
#save(ef.r.squared, file='C:/Dan/_Fire_tools/r_scripts_functions/Efr2.rda')
#save(aic.manual, file='C:/Dan/_Fire_tools/r_scripts_functions/aic.rda')

#Perplexity code was too complicated and didn't work; decided to do 
#simpler manual calcs instead (see below); may delete or archive Perplex
#code afterwards

#Perplex code - kept here for posterity purposes
#Generated by prompting Perplexity Pro and lots of trial and error
#get data
df.m25 <- read_csv(file='c:/Dan/_Fire_tools/r_scripts_functions/df_m25.csv')

#Build function
fixed_lm <- function(formula, data, slope) {
  # Extract x and y from the formula and data
  vars <- all.vars(formula)
  x <- data[[vars[2]]]
  y <- data[[vars[1]]]
  
  n <- length(y)
  
  # Calculate predictions and residuals
  y_pred <- slope * x
  residuals <- y - y_pred
  
  # Calculate RSS and TSS
  rss <- sum(residuals^2)
  tss <- sum((y - mean(y))^2)
  
  # Calculate R-squared and adjusted R-squared
  r_squared <- 1 - (rss / tss)
  adj_r_squared <- 1 - (1 - r_squared) * ((n - 1) / (n - 2))
  
  # Calculate residual standard error
  df <- n - 1  # degrees of freedom
  rse <- sqrt(rss / df)
  
  # Create coefficient matrix
  coef_matrix <- matrix(c(0, slope), ncol = 1)
  rownames(coef_matrix) <- c("(Intercept)", vars[2])
  colnames(coef_matrix) <- "Estimate"
  
  # Calculate standard errors (approximation)
  se <- c(0, rse / sqrt(sum((x - mean(x))^2)))
  
  # Calculate t-values and p-values
  t_values <- coef_matrix[, 1] / se
  p_values <- 2 * pmin(pt(abs(t_values), df), 1 - pt(abs(t_values), df))
  
  # F-statistic
  f_statistic <- (r_squared / (1 - r_squared)) * (df / 1)
  f_p_value <- pf(f_statistic, 1, df, lower.tail = FALSE)
  
  # Combine into coefficients table
  coefficients <- cbind(coef_matrix, "Std. Error" = se, 
                        "t value" = t_values, 
                        "Pr(>|t|)" = p_values)
  
  # Create and return the model object
  result <-
    list(
      coefficients = coefficients,
      residuals = residuals,
      fitted.values = y_pred,
      rank = 2,
      df.residual = df,
      call = match.call(),
      terms = terms(formula),
      model = model.frame(formula, data),
      xlevels = list(),
      qr = list(qr = matrix(c(rep(1, n), x), ncol = 2), 
                rank = 2, qraux = c(1, 1), pivot = 1:2),
      sigma = rse,
      r.squared = r_squared,
      adj.r.squared = adj_r_squared,
      fstatistic = c(value = f_statistic, 
                     numdf = 1, dendf = df, 
                     p.value = f_p_value)
    )
  
  class(result) <- c("fixed_lm", "lm")
  result
}

#summary function
summary.fixed_lm <- function(object, ...) {
  res <- list(
    call = object$call,
    terms = object$terms,
    residuals = object$residuals,
    coefficients = object$coefficients,
    sigma = object$sigma,
    df = c(object$rank, object$df.residual, object$rank),
    r.squared = object$r.squared,
    adj.r.squared = object$adj.r.squared,
    fstatistic = c(value = NA, numdf = 1, dendf = object$df.residual),
    cov.unscaled = matrix(0, nrow = 2, ncol = 2),
    fstatistic = object$fstatistic
  )
  
  class(res) <- "summary.lm"
  res
}

#Display summary function
print.summary.fixed_lm <- function(x, ...) {
  cat("\nCall:\n")
  print(x$call)
  
  cat("\nResiduals:\n")
  if (length(x$residuals) > 5) {
    rq <- quantile(x$residuals)
    names(rq) <- c("Min", "1Q", "Median", "3Q", "Max")
    print(rq, digits = 3)
  } else {
    print(x$residuals, digits = 3)
  }
  
  cat("\nCoefficients:\n")
  printCoefmat(x$coefficients, P.values = TRUE, has.Pvalue = TRUE)
  
  cat("\nResidual standard error:", format(x$sigma, digits = 4),
      "on", x$df[2], "degrees of freedom")
  cat("\nMultiple R-squared: ", format(x$r.squared, digits = 4),
      ",\tAdjusted R-squared: ", format(x$adj.r.squared, digits = 4),
      "\n", sep = "")
  if (!is.null(x$fstatistic)) {
    cat("F-statistic:", format(x$fstatistic["value"], digits = 4), "on", 
        x$fstatistic["numdf"], "and", x$fstatistic["dendf"], "DF,  p-value:",
        format.pval(x$fstatistic["p.value"], digits = 4), "\n") }
}


m25 <- fixed_lm(ROS ~ ws, data = df.m25, slope = 0.25)


